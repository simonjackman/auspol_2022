---
title: "Calling `CTGAN` from `R`"
date: now
date-format: "h:mmA D MMMM YYYY"
author:
  - name: "Professor Simon Jackman"
    orcid: 0000-0001-7421-4034
    affiliation: "University of Sydney"
    email: "simonjackman@icloud.com"
    url: https://simonjackman.netlify.app
website:
  google-analytics: 'G-DD0XG6JZDH'
format:
  html:
    theme: cosmo
    css: custom.css
    mainfont: Avenir Next
    fontsize: 16px
    toc: true
    number-sections: true
    fig-width: 6.5
    fig-height: 6.5
    code-tools: true
    code-copy: hover
    code-link: true
    code-fold: show
    smooth-scroll: true
    self-contained: true
    embed-resources: true
    include-in-header: 
      file: "js/external_load.js"
engine: knitr
execute: 
  echo: fenced
---

# Setup

We use a mix of `python` code chunks and invocations of `python` from `R` code chunks via the `reticulate` package.

```{r}
#| results: hide
#| echo: false
#| message: false
library(tidyverse)
library(here)
library(knitr)
```

Which `python` is being used by `R` and `quarto`?:
```{r}
#| code-fold: true
library(reticulate)
py_exe()
```

Load `ctgan` and demo data.   To feed the `R` copy of the data back to `ctgan` on the `python` side, we coerce `doubles` to `int`.   We also trim leading and trailing whitespace from strings.  We also carve out our own 1,000 record subset of the data.
```{r}
ctgan = import("ctgan")

test_data = ctgan$load_demo() %>% 
  as_tibble() %>%
  mutate(
    across(where(is.double), ~ as.integer(.x)),
    across(where(is.character), ~ str_squish(.x))
  )

my_data = test_data %>% slice(1:1000)
```
In `python`, crate an array of the names of columns that contain discrete data:
```{python}
test_data = r.ctgan.load_demo()

# Names of the columns that are discrete
discrete_columns = [
     'workclass',
     'education',
     'marital-status',
     'occupation',
     'relationship',
     'race',
     'sex',
     'native-country',
     'income'
]
```

The following code runs from inside `RStudio` at the console, but causes `quarto` to hang.   Hence we run the code separately, saving the serialised model object to file and re-loading it into this `quarto` workflow:   

```{python}
#| label: run-model
#| eval: false
from ctgan import CTGAN
from ctgan import load_demo
real_data = load_demo()

# Names of the columns that are discrete
discrete_columns = [
     'workclass',
     'education',
     'marital-status',
     'occupation',
     'relationship',
     'race',
     'sex',
     'native-country',
     'income'
]

m = CTGAN(epochs=25)
setattr(m,"_verbose",True)
m.fit(real_data, discrete_columns)
```

```{r}
#| eval: false
py_save_object(py$m,filename=here("analysis/gan/ctgan.pickle"))
```

Load the serialised `python` model object:
```{r}
model <- py_load_object(here("analysis/gan/ctgan.pickle"))
```

List of attributes of CTGAN `model`:
```{r}
py_list_attributes(model)
```
```{r}
py_get_attr(model,"__dict__") %>% py_to_r()
```

# Synthetic data

From `R` (using `reticulate`), call the `sample` method on the `python` model object to generate 25 rows of synthetic data:

```{r}
#| label: create-synthetic-data
#| eval: true
s <- model$sample(25L)
```

```{r}
#| eval: true
kable(s) %>% kableExtra::kable_styling(font_size = 10)
```



