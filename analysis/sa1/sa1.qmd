---
title: "Small area estimates of vote shares: the 2022 Australian federal election"
title-block-banner: true
description: |
  We provide estimates of vote shares at the SA1 level from the 2022 Australian federal election, making use of a mapping from polling places to SA1s provided by the Australian Electoral Commission and methods for solving inverse problems from statistics, computer science and the social sciences.
date: now
date-format: "h:mmA D MMMM YYYY"
author:
  - name: "Professor Simon Jackman"
    orcid: 0000-0001-7421-4034
    affiliation: "University of Sydney"
    email: "simonjackman@icloud.com"
    url: https://simonjackman.netlify.app
website:
  google-analytics: 'G-DD0XG6JZDH'
format:
  html:
    theme: cosmo
    css: custom.css
    mainfont: Avenir Next
    fontsize: 16px
    toc: true
    number-sections: true
    fig-width: 6.5
    fig-height: 6.5
    echo: false
    code-tools: true
    smooth-scroll: true
    self-contained: true
    include-in-header: 
      file: "js/external_load.js"
tbl-cap-location: bottom    
crossref:
  tbl-title: Table
execute:
  keep-md: false
  warning: false
  error: false
  echo: false
bibliography: small_area.bib  
---

```{r}
library(knitr)
library(tidyverse)
library(here)
library(sf)
sa1_counts <- read_csv(here("data/2022/SA1/SA1_Citizen_Adult.csv"),
                       skip = 12,
                       col_names = c("SA1_CODE21","cit","noncit","unknown","total")) %>% 
  filter(grepl(SA1_CODE21,pattern="^[0-9]"))

sa1 <-
  read.csv(file = here("data/2022/SA1/2022-federal-election-votes-sa1.csv")) %>%
  filter(votes > 0)

## convert 2016 SA1 to 2022 SA1
cfile <- read.csv(file = here("data/2022/SA1/correspondence/CG_SA1_2016_SA1_2021.csv")) %>%
  mutate(sa1_2016_7 = paste0(str_sub(SA1_MAINCODE_2016,1,1),
                             str_sub(SA1_MAINCODE_2016,6,11)),
         sa1_2021_7 = paste0(str_sub(SA1_CODE_2021,1,1),
                             str_sub(SA1_CODE_2021,6,11)))

sa1 <- sa1 %>%
  mutate(ccd_id = as.character(ccd_id)) %>%
  left_join(cfile %>%
              select(starts_with("sa1"),
                     ratio = RATIO_FROM_TO),
            by = c("ccd_id" = "sa1_2016_7")) %>% 
  rename(SA1_CODE21 = SA1_CODE_2021)

## drop no fixed address SA1s
sa1 <- sa1 %>% 
  filter(!grepl(pattern = "9999$",
                as.character(ccd_id)
                )
         )

## load observed outputs
load(here("data/2022/wentworth/wentworth.RData"))
y   <-
  y_wentworth %>% arrange(pp_nm) %>% select(-pp_nm, -votes_total_pp) %>% as.matrix()

y_n <-
  y_wentworth %>% arrange(pp_nm) %>% pull(votes_total_pp) %>% as.vector()
y <- y * y_n

## measurement/compression matrix
load(here("data/2022/wentworth/t_wentworth_mat.RData"))

sa1_n <-
  sa1_wentworth %>% group_by(SA1_CODE21) %>% summarise(n = sum(votes * ratio)) %>% ungroup() %>% mutate(keep = n > 30)

counts_long <- sa1_wentworth %>%
  mutate(v = round(votes * ratio)) %>%
  arrange(pp_nm, SA1_CODE21) %>%
  select(pp_nm, SA1_CODE21, v) %>%
  filter(v > 0)

counts_data <- sa1_wentworth %>%
  ##left_join(sa1_n, select(SA1_CODE21,keep),by = "SA1_CODE21") %>%
  ##filter(keep) %>%
  mutate(v = round(votes * ratio)) %>%
  pivot_wider(
    id_cols = "pp_nm",
    names_from = "SA1_CODE21",
    values_from = "v",
    values_fill = 0
  ) %>%
  arrange(pp_nm)

counts <- counts_data %>%
  select(-pp_nm) %>%
  as.matrix()


## adjust vote vectors to sum to turnout over SA1s
y_normed <- y_wentworth %>%
  arrange(pp_nm) %>%
  pivot_longer(cols = where(is_double),
               names_to = "party",
               values_to = "y") %>%
  filter(party != "votes_total_pp") %>%
  left_join(
    counts_data %>%
      pivot_longer(
        cols = where(is.double),
        names_to = "SA1_CODE21",
        values_to = "v"
      ) %>%
      group_by(pp_nm) %>%
      summarise(n = sum(round(v))) %>%
      ungroup(),
    by = "pp_nm"
  ) %>%
  left_join(y_wentworth %>%
              select(pp_nm, votes_total_pp),
            by = "pp_nm") %>%
  mutate(y_old = round(y * votes_total_pp),
         y_new = round(y * n))

check <- y_normed %>%
  group_by(pp_nm) %>%
  summarise(y_new = sum(y_new), n = n[1]) %>%
  ungroup() %>%
  mutate(d = y_new - n)

y_normed <- left_join(y_normed,
                      check %>% select(pp_nm, d),
                      by = "pp_nm") %>%
  mutate(y_new = if_else(party == "INF", y_new - d, y_new)) %>%
  select(-d)
```

# Summary {.highlights .unnumbered}

-   Political parties, candidates and analysts seek intelligence about voting intentions for small geographic units, so as to efficiently allocate campaign resources and to better understand the predictors of vote choices. This involves using data observed at relatively coarse levels of spatial resolution (e.g., electoral divisions, polling places) to make inferences with respect to component smaller areal units (e.g., postcodes, neighbourhoods), a long-standing problem in statistics and the social sciences.

-   SA1 or "Statistical Area 1" is the most granular unit of geography for which the Australian Bureau of Statistics (ABS) provides tabulations of demographic and social characteristics, with a median adult citizen population of just  `r sa1_counts %>% filter(total>0) %>% summarise(n=median(cit)) %>% pull(n)` in the 2021 Census.

-   After each federal election, the AEC produces a [data file](https://www.aec.gov.au/Elections/Federal_Elections/2022/files/downloads/2022-federal-election-votes-sa1.csv "AEC SA1 vote statistics") of voter turnout counts for each polling place utilized by voters in each SA1.  The AEC also provides vote tallies for each polling place. 

- Even with the correspondence between polling places and SA1s, using polling place vote tallies to infer the distribution of votes by party at the SA1 level lacks a unique solution (a case of an ill-posed inverse problem).  This is seldom acknowledged by practitioners who typically employ a simple, deterministic algorithm for estimating SA1 vote distributions, presented in @sec-deterministic.

-   We assess different approaches for generating plausible estimates of SA1 level vote shares, comparing their utility to practitioners and analysts. Our preferred approach draws on hierarchical Bayesian modeling, utilizing Census information about the social and demographic composition of SA1s to supplement the polling place vote tallies and the polling place/SA1 correspondence.

-   The methodology we survey and utilize here has many applications in policy settings such as health, transport, education and public safety and commercial settings such as marketing and property development.

# The problem, briefly stated

We observe counts of votes cast for each party/candidate at each polling place ($\boldsymbol{y}$). Separately, we have data providing turnout counts at each polling place disaggregated to small spatial units (SA1s), which we encode in a matrix $\boldsymbol{A} = \{ A_{ij} \}$ with $A_{ij}$ the number of voters turning out at polling place $i$ who reside in SA1 $j$.  What we want to recover is the SA1 level distribution of votes for each party, $\boldsymbol{x}$.

Given $\boldsymbol{y}$ and $\boldsymbol{A}$ can we recover $\boldsymbol{x}$?  Further, do social and demographic features of SA1s, $\boldsymbol{z}$ help with the recovery of $\boldsymbol{x}$?

A graphical sketch of the model appears below; the node corresponding to the unobserved $\boldsymbol{x}$ is displayed as a circle, while observed quantities are represented with squares.

```{r}
DiagrammeR::grViz("
                  digraph rmarkdown {
                  
                  graph [rankdir = LR, fontname = 'Avenir']
                  
                  node [shape = square]
                  z [label = 'z \n SA1 \n demographics'] 
                  A [label = 'A \n aggregation \n matrix']
                  y [label = 'y \n polling place \n counts by party']
                  
                  node [shape = circle]
                  x [label = 'x \n SA1 \n vote counts \n by party']
                  
                  z -> x -> A -> y
                  
                  }
                  ",
                  height = 200)
```

# Key terms: electoral divisions, polling places and Census geography

Voter enrolment and turnout is compulsory in Australia. Electoral authorities maintain a high quality list of enrolled voters and their current addresses, often relying on information from other government agencies to keep address information current.

Since 2019 Australia's House of Representatives has comprised 151 single-member electoral divisions. The median number of voting locations (including postal voting) was 55 per division, with 139 locations used in the large and sparsely populated division of Grey in South Australia and just 34 in the division of Solomon centred on Darwin in the Northern Territory.

Electoral divisions sometimes span multiple local government areas and state legislative districts, but elections at these lower levels of government are not held concurrently with a Federal election.[^1] Accordingly, no great administrative complexity arises from **not** insisting that voters turn out at polling places close to their registered address. In short, Australian voters are not allocated to *precincts* within constituencies as is the case in the United States.

[^1]: Section 394 of the *Commonwealth Electoral Act*.

Consistent with making the legal obligation to turn out easy to fulfil, Australian voters have many options as to *where* and *how* or *when* to turn out. So, while many Australians opt to turn out at the polling place closest to their residence, this is far from universal. Consequently, vote shares reported for a given polling place are generated by a *mix* of voters from across the enclosing division.

# Polling places draw on many SA1s

The AEC has produced a [file](https://www.aec.gov.au/Elections/Federal_Elections/2022/files/downloads/2022-federal-election-votes-sa1.csv "AEC SA1 vote statistics") that provides House of Representatives voter turnout counts from the 2022 election at each of the polling places utilised by the voters residing in each SA1 (the quantities denoted $A_{ij}$, above).

```{r}
library(knitr)
library(tidyverse)
library(here)


library(fst)
aec_ppid <- read_fst(here("../auspol_2022/data/aec_ppid.fst"))
```

The AEC's SA1 file:

-   has `r sa1 %>% nrow() %>% format(.,big.mark=",")` records with non-zero vote counts,

-   spans `r sa1 %>% distinct(SA1_CODE21) %>% nrow() %>% format(.,big.mark=",")` unique SA1s,[^2]

-   `r sa1 %>% distinct(pp_id) %>% nrow() %>% format(.,big.mark=",")` unique `pp_id` (polling places) with non-zero vote counts

-  and `r format(sum(sa1$votes),big.mark=",")` voters.

[^2]: The codes used in the AEC's SA1 files are actually 7-digit SA1 identifiers from the 2016 Census. We map these to SA1s used in the 2021 Census using a correspondence file provided by the ABS.

```{r}
sa1 <- sa1 %>% 
  group_by(div_nm,SA1_CODE21) %>%
  mutate(p = ratio*votes/sum(ratio*votes)) %>% 
  ungroup()

sa1_shannon <- sa1 %>% 
  group_by(div_nm,SA1_CODE21) %>% 
  summarise(shannon = -sum(p*log(p)),
            gini_simpson = 1 - sum(p*p),
            n = n(),
            pmax=max(p)) %>% 
  ungroup()

modal_count <- sa1_shannon %>% count(n) %>% slice_max(nn) %>% pull(n)
```



For each SA1 we compute the number of polling places utilised by its voters and the share of its total votes from each of the `pp_id` used by its voters. @fig-histogram-ppid-counts shows that the modal number of polling places used per SA1 is `r modal_count`, with a small cluster of SA1s whose voters make use of just 1 polling place.

```{r}
#| label: fig-histogram-ppid-counts
#| fig-cap: "Histogram, number of polling places used per SA1"
library(ggplot2)
ggplot(sa1_shannon,
       aes(x = n)) + 
  geom_histogram(binwidth = 1) +
  theme_minimal(base_family = "Avenir") + 
  theme(panel.grid.minor = element_blank())
```

<!-- We also examine the concentration or diffusion of voters across polling places within each SA1. We first compute $t_{ij} = A_{ij}/\sum_{i=1}^{n_j} A_{ij}$, the _proportion_ of voters from SA1 $j$ who turn out to vote at polling place $i \in 1, \ldots, n_j$. The Gini-Simpson index  -->

<!-- $$ -->

<!-- G_j = 1 - \sum_{i=1}^{n_j} t_{ij}^2 -->

<!-- $$  -->

<!-- measures the *diversity* of the $t_{ij}$ within SA1 $j$ and in this case is equal to the probability that two randomly sampled voters in the $j$-th SA1 turned out at different polling places. -->

```{r}
#| eval: false
#| label: fig-histogram-gini-simpson
#| fig-cap: "Histogram, Gini-Simpson diversity index over SA1s"
library(ggplot2)
ggplot(sa1_shannon,
       aes(x = gini_simpson)) + 
  geom_histogram() +
  theme_minimal(base_family = "Avenir") + 
  theme(panel.grid.minor = element_blank())
```

<!-- @fig-histogram-gini-simpson shows the distribution of the Gini-Simpson diversity index $G_i$ across SA1s; the probability that two randomly selected voters from a SA1 vote at different polling places is high, typically about .75.   -->

<!-- Most SA1s contribute to the vote tallies observed over a range of values for $n_i$, the number of polling places utilised by voters in a particular SA1. -->

```{r}
#| eval: false
#| label: fig-shannon
#| fig-cap: Concentration/diversity of voter turnout locations for each SA1; vertical axis is the share of voter turnout recorded at the most utilised polling place for a SA1; horizontal axis is the Gini-Simpson diversity index, the probability that two randomly selected voters from a SA1 turned out to vote at the same polling place.
ggplot(sa1_shannon %>%
         mutate(
           z = cut(
             n, 
             breaks = c(0, 
                        quantile(n,
                                 seq(from = 1 / 12, to = 1, length = 12)
                                 )
                        ),
             right = TRUE
             )
           ),
       aes(x = gini_simpson,
           y = pmax)) +
  geom_point(shape = 1,
             alpha = .5,
             size = .25) +
  scale_x_continuous("Gini-Simpson diversity index") +
  scale_y_continuous("Maximum p") +
  facet_wrap(~ z) +
  theme_minimal(base_family = "Avenir") +
  theme(panel.grid.minor = element_blank())
```

We examine the spread of SA1 votes across polling places in the following table: for a each SA1 we order the contributing polling places by the number of votes from the SA1 cast at that polling place. We then compute the cumulative share of SA1 turnout from the largest/most-utilised polling place to the smallest/least-utilised polling place. After a cumulative $n$ = 1, 2, $\ldots$ polling places, we compute the median proportion of SA1 turnout and the 5th and 95th percentile of the cumulative turnout across SA1s. These quantities are reported in the table below:

```{r}
tab <- sa1 %>%
  group_by(div_nm,SA1_CODE21) %>%
  arrange(desc(votes*ratio)) %>%
  mutate(i = 1:n(),
         j = i / n(),
         p = cumsum(votes*ratio) / sum(votes*ratio)) %>%
  ungroup() %>%
  group_by(i) %>%
  summarise(q05 = quantile(p, .025, na.rm = TRUE),
            q50 = median(p, na.rm=TRUE),
            q95 = quantile(p, .975, na.rm=TRUE)) %>%
  ungroup()

ojs_define(tab_ojs=tab)
```

```{ojs}
tab_spread = transpose(tab_ojs)
```

```{ojs}
Inputs.table(tab_spread, {
  columns: [
    "i",
    "q50",
    "q05",
    "q95"
    ],
    align: {
      i: "center",
      q50: "center",
      q05: "center",
      q95: "center"
    },
    format: {
      i: x => x.toFixed(0),
      q50: x => (100*x).toFixed(1),
      q05: x => (100*x).toFixed(1),
      q95: x => (100*x).toFixed(1)
      },
   header: {
    i: "Cumulative polling places",
    q50: "Cumulative share of SA1 turnout (median)",
    q05: "5%",
    q95: "95%" 
    }
})
```

We can also examine the mapping from SA1s to polling places, producing the following table. Absentee votes, postal votes and other forms of declaration votes are bundled into one pseudo polling place for entire electoral divisions, which usually draw from almost all SA1s spanned by the division; we exclude votes cast in this fashion from the calculations in the table below, while including them in the analysis elsewhere in this report.

```{r}
tab <- sa1 %>%
  filter(pp_id!=0) %>% 
  mutate(ppp = paste(pp_id,pp_nm)) %>% 
  group_by(div_nm,ppp) %>%
  arrange(desc(votes*ratio)) %>%
  mutate(i = 1:n(),
         j = i / n(),
         p = cumsum(votes*ratio) / sum(votes*ratio)) %>%
  ungroup() %>%
  group_by(i) %>%
  summarise(q05 = quantile(p, .025, na.rm = TRUE),
            q50 = median(p, na.rm = TRUE),
            q95 = quantile(p, .975, na.rm = TRUE)
            ) %>%
  ungroup()

ojs_define(pp_sa1_ojs=tab)
```

```{ojs}
pp_sa1 = transpose(pp_sa1_ojs)
```

```{ojs}
Inputs.table(pp_sa1, {
  columns: [
    "i",
    "q50",
    "q05",
    "q95"
    ],
    align: {
      i: "center",
      q50: "center",
      q05: "center",
      q95: "center"
    },
    format: {
      i: x => x.toFixed(0),
      q50: x => (100*x).toFixed(1),
      q05: x => (100*x).toFixed(1),
      q95: x => (100*x).toFixed(1)
      },
   header: {
    i: "Cumulative SA1s",
    q50: "Cumulative share of polling place turnout (median)",
    q05: "5%",
    q95: "95%" 
    }
})
```

This inspection of the data reveals

-   typically, combining results from many polling places will be required to generate estimates of vote shares at the SA1 level, or conversely, many SA1s contribute to polling place level results.

-   while it is sometimes the case that one or two polling places account for the bulk of votes from a given SA1, this is relatively unusual. More often than not, even **six** polling places account for less than 90% of the turnout of a SA1, and typically about **nine** polling places are required to account for 95% of turnout in any SA1.

-   conversely, about six or seven SA1s generally account for 50% of the votes cast at a given polling place, but we usually need **fifty-seven** SA1s to cover 95% of the votes cast at a polling place.

<!-- ## Divisions with split SA1s -->

```{r}
ced_split <- left_join(
  sa1 %>%
    distinct(div_nm, ccd_id) %>%
    group_by(div_nm) %>%
    summarise(n = n()) %>%
    ungroup(),
  sa1 %>%
    distinct(div_nm, ccd_id) %>%
    group_by(ccd_id) %>%
    mutate(n = n()) %>%
    ungroup() %>%
    filter(n > 1) %>%
    group_by(div_nm) %>%
    summarise(n_split = n()) %>%
    ungroup(),
  by = "div_nm") %>%
  arrange(desc(n_split))
```

<!-- `r nrow(ced_split)` divisions share at least one SA1 with another division; @tbl-ced-split-sa1 shows the divisions with 10 or more split SA-1s. The AEC's SA-1 file produces counts of turnout separated by division in each of these cases. -->

<!-- ```{r} -->

<!-- #| label: tbl-ced-split-sa1 -->

<!-- #| tbl-cap: "Divisions with 10 or more split SA-1s" -->

<!-- kable(ced_split %>% filter(n_split>9), -->

<!--       col.names = c("Division","Total SA1s","Split SA1s")) %>%  -->

<!--   kableExtra::kable_styling() -->

<!-- ``` -->

# Estimating SA1 level vote shares

The mapping from SA1s to polling places is not especially *sparse*.  Of the voters turning out at a polling place, usually only a small proportion come from a given SA1 and they usually constitute only a small proportion of the voters residing in a SA1.  Thus, in general, vote counts observed at the polling place level will not supply much information about the vote shares of any particular SA1.

To make progress, we consider the following model of polling place vote tallies. With $P$ parties/candidates, each polling place $i \in 1, \ldots, n$ produces a vector of $P$ vote counts $y_i = (y_{i1}, \ldots, y_{iP})'$.  SA1 $j \in 1, \ldots, m$ has $A_{ij}$ voters turning out at polling place $i$, who contribute unobserved vote counts $\zeta_{ij} = (\zeta_{ij1}, \zeta_{ij2}, \ldots, \zeta_{ijP})'$ to $y_i$.

By construction, $y_i$ is the piecewise sum of vectors of vote counts $\zeta_{ij}$, where $j$ indexes the originating SA1s: 
$$
y_{i} = \sum_{j=1}^m \zeta_{ij}, \qquad \sum_{p=1}^P \zeta_{ijp} = A_{ij}
$$ {#eq-y}

where the summation over SA1s $j = 1, \ldots, m$ is piecewise with respect to each of the $P$ elements of $\zeta_{ij}$.^[In practice, for computational efficiency we define $\zeta_{ij}$ and summations over them only for those $(i,j)$ pairs where $A_{ij} > 0$.]

It is sometimes convenient to express the unobserved vote counts $\zeta_{ij}$ in terms of unobserved proportions $\lambda_{ij}$, where $\zeta_{ij} = \lambda_{ij} \cdot A_{ij}$. In particular, we estimate SA1 level vote counts by summing over the vote shares (or counts) originating from SA1 $j$ recorded at polling places $i = 1, \ldots, n$:

$$
(x_{j1}, x_{j2}, \ldots, x_{jP})' = \, x_j = \, \sum_{i=1}^n \zeta_{ij} \, = \, \sum_{i=1}^n \lambda_{ij} \cdot A_{ij},
$$ {#eq-x}

with the summation over the destination polling places $i$ for voters from SA1 $j$.  Trivially, SA1 vote proportions are simply an element-wise, weighted average of the $\boldsymbol{\lambda}$ computed over the destination polling places for SA1 $j$:  
$$
(\pi_{j1}, \pi_{j2}, \ldots, \pi_{jP})' = \, \pi_j = \, 
\sum_{i=1}^n \frac{\zeta_{ij}}{A_{ij}} 
\, = \, 
\frac{\sum_{i=1}^n \lambda_{ij} \cdot A_{ij}}{\sum_{i=1}^n A_{ij}}.
$$ {#eq-pi}

## "Ill-posed" inverse problems lack unique solutions

@eq-y highlights a key feature of the inferential task at hand.  We have $n \times P$ pieces of information in $\boldsymbol{y}$, the $n$ polling place level vectors of vote counts for the $P$ parties/candidates.  Our model expresses these in terms of a weighted sum of We seek estimates of $m > n$ SA1 level vectors of vote counts $\boldsymbol{x}$, or $m \times P$ unknown quantities.   @eq-y and @eq-x shows that the relationship between $\boldsymbol{y}$ and $\boldsymbol{x}$ is linear, but with $m > n$ the implied system of linear equations is under-determined, with a _set_ of possible $\zeta_{ij}$ (or equivalently, $\lambda_{ij}$) that satisfy @eq-y rather than a unique solution.  

In the language of mathematics, computer science and engineering, our problem is one of trying to recover an unobserved input from an output: an "inverse" problem".   Further, the inverse problem here is "ill-posed" in that the measurement process compresses or coarsens the SA1 level inputs to polling place level outputs, generating the analogue to an under-determined system of equations.  The SA1-to-polling place turnout counts $A_{ij}$ only supply information about the _sum_ of the $P$ elements of $\zeta_{ij}$, reducing the solution space but leaving _many_ configurations of SA1-level vote tallies consistent with the polling place tallies.

From the outset, therefore, we ought to concede that _there is no unique set_ of $m$ SA1 level vote tallies $\boldsymbol{x}$ consistent with the $n$ polling place tallies $\boldsymbol{y}$.  This is seldom acknowledged by practitioners who typically employ the simple, deterministic algorithm for estimating $\boldsymbol{x}$ we study in @sec-deterministic.  Our purpose here is to restate this overlooked point, explore feasible solutions and observe what these estimates (and the variation among them) imply for downstream inferences about political preferences.

# Example: the electoral division of Wentworth

We consider an example from the 2022 election, the House of Representatives division of Wentworth in Sydney's Eastern suburbs. This division was one of six "blue ribbon" seats where Liberal Party incumbents were defeated by independent candidates and so the subject of considerable campaign effort, analysis and media attention.

Wentworth encompasses some of Australia's wealthiest neighbourhoods on the southern shore of Sydney Harbour to the east of the Sydney CBD (e.g., Darling Point, Double Bay, Point Piper, Rose Bay, Vaucluse, Watson's Bay), but also includes less wealthy and more diverse neighborhoods such as Bondi, Bondi Junction, Darlinghurst, Kings Cross, Randwick and Clovelly.

```{r}
#| eval: false
y_wentworth <- aec_ppid %>% 
  filter(div_nm == "Wentworth") %>%
  mutate(PartyAb = case_when(
    PartyAb %in% c("ON","UAPP","LDP") ~ "OTH",
    TRUE ~ PartyAb)) %>% 
  mutate(PartyAb = fct_relevel(PartyAb, "INF", after = Inf)) %>% 
  group_by(pp_id,pp_nm,PartyAb) %>% 
  summarise(votes_pp = sum(votes_pp)) %>% 
  ungroup() %>% 
  group_by(pp_id,pp_nm) %>% 
  mutate(votes_p = votes_pp/sum(votes_pp)) %>% 
  ungroup() %>% 
  pivot_wider(id_cols = pp_nm,names_from = PartyAb,values_from = votes_p) %>% 
  left_join(aec_ppid %>%
              filter(div_nm == "Wentworth") %>%
              select(pp_nm,votes_total_pp) %>% 
              distinct(),
            by = "pp_nm") %>% 
  select(pp_nm,votes_total_pp,everything())

##save(y_wentworth,file=here("data/wentworth.RData"))
```


This variation is reflected in the vote shares across the various polling places in the table, below, displaying the `r nrow(y_wentworth)` polling place level votes shares as percentages, along the total number of votes cast at each polling place; these data are [freely available](https://results.aec.gov.au/27966/Website/Downloads/HouseStateFirstPrefsByPollingPlaceDownload-27966-NSW.csv "NSW 1st preferences by candidate by polling place (CSV)") from the AEC. We collapse votes for One Nation and the Palmer United Australia Party into one "Other" group. "INF" are informal or "spoiled" ballots. The table can be sorted by clicking on the column headers.

```{r}
ojs_define(y_wentworth_ojs = y_wentworth)
```
```{ojs}
y_wentworth = transpose(y_wentworth_ojs)
```

```{ojs}
//| label: fig-wentworth-pp
//| fig-cap: "Wentworth vote shares by polling place, 2022 House of Representatives election.  Source: Australian Electoral Commission."
Inputs.table(y_wentworth, {
  rows: 1000,
  columns: [
    "pp_nm",
    "votes_total_pp",
    "ALP",
    "GRN",
    "IND",
    "LP",
    "OTH",
    "INF"
 ],
    align: {
      pp_nm: "left"
    },
    format: {
      votes_total_pp: x => d3.format(",")(x),
      ALP: x => (100*x).toFixed(1),
      GRN: x => (100*x).toFixed(1),
      IND: x => (100*x).toFixed(1),
      LP: x => (100*x).toFixed(1),
      OTH: x => (100*x).toFixed(1),
      INF: x => (100*x).toFixed(1)
      },
   header: {
    pp_nm: "Polling Place",
    votes_total_pp: "Votes"
    }
})
```

```{r}
sa1_wentworth <- sa1 %>% 
  filter(div_nm == "Wentworth")

t_wentworth <- sa1_wentworth %>% 
  group_by(pp_nm) %>% 
  mutate(v = votes*ratio/sum(votes*ratio)) %>% 
  ungroup() %>% 
  pivot_wider(id_cols = pp_nm,
              names_from = SA1_CODE21,
              values_from = v,
              values_fill = 0)

t_wentworth_mat <- t_wentworth %>% 
  select(-pp_nm) %>% 
  as.matrix()

#save("sa1_wentworth",
#     "t_wentworth",
#     "t_wentworth_mat",
#     file=here("data/t_wentworth_mat.RData"))

z <- matrix(t_wentworth_mat > 0,
            nrow(t_wentworth_mat),
            ncol(t_wentworth_mat))

dimnames(z) <- list(t_wentworth$pp_nm,NULL)

# indx <- 1:nrow(z)
# indx0 <- indx
# for(iter in 1:50){
#   indx <- indx[order(apply(z,1,sum))]
#   z <- z[order(apply(z,1,sum)),]
#   z <- z[,order(apply(z,2,sum))]
#   if(any(indx!=indx0)){
#     cat(paste("changed!\n"))
#   }
#   indx0 <- indx
# }

ldata <- data.frame(y = as.vector(row(z)),
                    x = as.vector(col(z)),
                    z = as.vector(z)) 
```

Wentworth spans `r ncol(z)` SA1s, depicted in the following map.   Orange circles correspond to polling places geo-coded by the AEC; mobile or "roaming" polling places are excluded (e.g., Special Hospital Team 1) as are postal votes, declaration pre-poll votes and absentee votes.  Rolling over each polling place will distinguish the smallest set of SA1s contributing 3/4s of turnout at that polling place (darker shading) from other SA1s contributing turnout to the polling place (lighter shading); SA1s not contributing turnout to the polling place are not displayed.  

This presentation reveals a reasonable degree of geographic concentration in Election Day, in-person turnout.  Polling places occupying the same physical location (as a pre-poll voting centre and then as an Election Day, in-person polling place) are jittered so as to be visually distinct.

```{r}
#| eval: false
#| label: geo-coded-pp
## this loads pp_geo
load(here("data/2022/pp_geo.RData"))
wentworth_pp_geo <- pp_geo %>%
  filter(DivisionNm == "Wentworth") %>%
  select(
    pp_nm = PollingPlaceNm,
    premises_nm = PremisesNm,
    lat = Latitude,
    long = Longitude
  ) %>%
  filter(!is.na(lat) & !is.na(long)) %>%
  mutate(
    dup = duplicated(lat) & duplicated(long),
    lat_new = if_else(dup,
                      lat + .001,
                      lat),
    long_new = if_else(dup,
                       long - .0005,
                       long)
    ) %>%
  select(-lat,-long) %>% 
  left_join(y_wentworth, by = "pp_nm") %>%
  left_join(
    expand_grid(
      pp_nm = y_wentworth %>% 
        pull(pp_nm),
      y %>%
        as_tibble() %>%
        pivot_longer(cols = everything(), names_to = "party") %>% group_by(party) %>%
        summarise(n = sum(value)) %>%
        ungroup() %>%
        mutate(p = n / sum(n)) %>%
        select(-n) %>%
        pivot_wider(names_from = party, values_from = p)
    ),
    by = "pp_nm",
    suffix = c("","_div")
    ) %>% 
  mutate(ALP_delta = ALP - ALP_div,
         GRN_delta = GRN - GRN_div,
         IND_delta = IND - IND_div,
         LP_delta  = LP  - LP_div,
         OTH_delta = OTH - OTH_div,
         INF_delta = INF - INF_div) %>%  
  st_as_sf(.,
           coords = c("long_new", "lat_new")) %>%
  geojsonio::geojson_json() %>%
  geojsonio::geojson_write(.,
                           file = here("data/2022/wentworth/pp_wentworth.json"))

```

```{r}
#| eval: false
## only need do this once
## read necessary shape files
## dump as json
sa1_wentworth_shp <- 
  st_read(
    dsn = "~/Downloads/SA1_2021_AUST_SHP_GDA2020"
  ) %>% 
  ##st_transform(crs="EPSG:7843") %>% 
  as(.,"sf") %>% 
  st_make_valid() %>% 
  semi_join(sa1_wentworth %>%
              distinct(SA1_CODE21),
            by = "SA1_CODE21")

geojsonio::geojson_write(sa1_wentworth_shp,
                         file = here("data/sa1_wentworth_shp.json"))

wentworth_shp <- terra::vect(here("../auspol_2022/data/2022/CED_shape")) %>% 
  st_as_sf() %>% 
  filter(Elect_div == "Wentworth") %>% 
  st_make_valid()

geojsonio::geojson_write(wentworth_shp,
                         file = here("data/wentworth_shp.json"))
```

```{r}
counts_long_concentrated <- counts_long %>% 
  group_by(pp_nm) %>% 
  arrange(desc(v)) %>% 
  mutate(cu = cumsum(v)/sum(v)) %>% 
  ungroup() %>% 
  mutate(hi = cu <= .75)

ojs_define(count_long_ojs = counts_long_concentrated)
```

```{ojs}
cdata = transpose(count_long_ojs)
```

```{ojs}
wentworth_json     = await FileAttachment("../data/2022/wentworth/wentworth_shp.json").json()
sa1_wentworth_json = await FileAttachment("../data/2022/wentworth/sa1_wentworth_shp.json").json()
pp_wentworth_json  = await FileAttachment("../data/2022/wentworth/pp_wentworth.json").json()
width = 800
height= 800
```

```{ojs}
L = require('leaflet@1.9.3')

//Stamen_TonerBackground = L.tileLayer('https://stamen-tiles-{s}.a.ssl.fastly.net/toner-background/{z}/{x}/{y}{r}.{ext}', {
//	attribution: 'Map tiles by <a href="http://stamen.com">Stamen Design</a>, <a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a> &mdash; Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
//	subdomains: 'abcd',
//	minZoom: 0,
//	maxZoom: 30,
//	ext: 'png'
//});

Stamen_TonerLite = L.tileLayer('https://stamen-tiles-{s}.a.ssl.fastly.net/toner-lite/{z}/{x}/{y}{r}.{ext}', {
	attribution: 'Map tiles by <a href="http://stamen.com">Stamen Design</a>, <a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a> &mdash; Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
	subdomains: 'abcd',
	minZoom: 0,
	maxZoom: 30,
	ext: 'png'
});

map2 = {
  let container = DOM.element ('div', { style: `width:${width}px;height:${height}px` });
  yield container;
  
  let map = L.map(container)
  let osmLayer = Stamen_TonerLite.addTo(map);
  
  // variable that stores name of selected polling place
  let thePP = "";

  // layer for outline of division 
  let Division_Layer  = L.geoJson(wentworth_json, 
    {
      weight: 3, 
      color: "#0000117f",
    }).addTo(map);


  // SA1 layer
  let init_style_SA1_elements = {
    fillColor: "transparent",
        weight: 0,
        color: "transparent"
  };
  
  function init_style_SA1(feature) {
    return init_style_SA1_elements;
  }
  
  function highlight_style_SA1(feature) {
    return {
      fillColor: "#0000A0",
      weight: 1,
      color: "black"
    }
  }  
  
  let SA1_Layer = L.geoJson(
    sa1_wentworth_json,
    {
      style: init_style_SA1,
      interactive: false
    }
    ).addTo(map);

  SA1_Layer.update = function(props){
    var theSA1s_high = cdata
      .filter(d => d.pp_nm == props.pp_nm & d.hi)
      .map(d => d.SA1_CODE21);  // SA1s feeding selected PP
    
    var theSA1s_low = cdata
      .filter(d => d.pp_nm == props.pp_nm & !d.hi)
      .map(d => d.SA1_CODE21);     
    
    this.eachLayer(function(layer){
      if(theSA1s_high.includes(layer.feature.properties.SA1_CODE21)){
        var theColor = "#0000B0";
        layer.setStyle({
        fillColor: theColor,
        weight: 1,
        color: "black"
        });
        console.log(layer.options);
      } else if(theSA1s_low.includes(layer.feature.properties.SA1_CODE21)){
        var theColor = "#0000B030";
        layer.setStyle({
        fillColor: theColor,
        weight: 1,
        color: "black"
        });
      }
      else {
        layer.setStyle(init_style_SA1_elements);
      }
    }
    );
  }

  // polling place layer
  var geojsonMarkerOptions = {
    //fillColor: "blue",
    //weight: 2,
    //opacity: 0.7,
    //color: 'blue',
    //fillOpacity: 0.0
    radius: 6,
    fillColor: "#ff7800",
    color: "#000",
    weight: 1,
    opacity: 1,
    fillOpacity: 0.8
    };
  
  function init_style_pp(feature){
    return geojsonMarkerOptions;
  }

  function onEachPP(feature, layer) {
    layer.on({
        mouseover: highlightFeature,
        mouseout: resetHighlight
    });
  }

  // highlight function
  function highlightFeature(e) {
    var layer = e.target;
    
    layer.setStyle({
        weight: 2,
        radius: 8
    });
    
    layer.openTooltip();
    
    layer.bringToFront();
    
    info.update(layer.feature.properties);
    
    thePP = layer.feature.properties.pp_nm;
    SA1_Layer.update(layer.feature.properties);
  }

  // mouseout function
  function resetHighlight(e) {
    PP_Layer.resetStyle(e.target);
    info.update();
  }

  let PP_Layer = L.geoJson(
    pp_wentworth_json,
    {
      pointToLayer: function (feature, latlng) {
        return L.circleMarker(latlng);
        },
      style: init_style_pp,
      onEachFeature: onEachPP
    }
    ).addTo(map);

  map.fitBounds(Division_Layer.getBounds());
  
  // information/text 
  var info = L.control();
  
  info.onAdd = function (map) {
    this._div = L.DomUtil.create('div', 'info'); // create a div with a class "info"
    this.update();
    return this._div;
  };

  // method that we will use to update the control based on feature properties passed
  info.update = function (props) {
  
    const f = d3.format(".1%");
    const g = function(x){
      return d3.format("+.1f")(100.0*x);
    };
    
    var infoTab = (props ? 
      "<table class = 'leaflet_popup_tab'>" + 
      "<tr><th>Party</th><th style='text-align:center'>%</th>" + 
      "<th style='text-align:center'>Division %</th>" +
      "<th style='text-align:center'>âˆ†</th>" +
      "</tr>" +
      "<tr>" + 
      "<td>ALP</td>" + 
      "<td style='text-align: right'>" + f(props.ALP)       + "</td>" + 
      "<td style='text-align: right'>" + f(props.ALP_div)   + "</td>" + 
      "<td style='text-align: right'>" + g(props.ALP_delta) + "</td>" +
      "</tr>" + 
      "<tr>" + 
      "<td>GRN</td>" +
      "<td style='text-align: right'>" + f(props.GRN) + "</td>" + 
      "<td style='text-align: right'>" + f(props.GRN_div) + "</td>" +  
      "<td style='text-align: right'>" + g(props.GRN_delta) + "</td>" + 
      "</tr>" +
      "<tr>" + 
      "<td>IND</td>" +
      "<td style='text-align: right'>" + f(props.IND) + "</td>" + 
      "<td style='text-align: right'>" + f(props.IND_div) + "</td>" +  
      "<td style='text-align: right'>" + g(props.IND_delta) + "</td>" + 
      "</tr>" +
      "<tr>" + 
      "<td>LP</td>" +
      "<td style='text-align: right'>" + f(props.LP) + "</td>" + 
      "<td style='text-align: right'>" + f(props.LP_div) + "</td>" +  
      "<td style='text-align: right'>" + g(props.LP_delta) + "</td>" + 
      "</tr>" +
      "<tr>" + 
      "<td>OTH</td>" +
      "<td style='text-align: right'>" + f(props.OTH) + "</td>" + 
      "<td style='text-align: right'>" + f(props.OTH_div) + "</td>" +  
      "<td style='text-align: right'>" + g(props.OTH_delta) + "</td>" + 
      "</tr>" +
      "<tr>" + 
      "<td>INF</td>" +
      "<td style='text-align: right'>" + f(props.INF) + "</td>" + 
      "<td style='text-align: right'>" + f(props.INF_div) + "</td>" +  
      "<td style='text-align: right'>" + g(props.INF_delta) + "</td>" + 
      "</tr>" +
      "</table>" 
      : "");
  
    this._div.innerHTML = '<h4>Wentworth polling places</h4>' +  (props ?
        '<b>' + props.pp_nm + '</b>' + 
        '<br>' + props.premises_nm + '<br>' + 
        '<br>' + "Turnout: " + d3.format(",")(props.votes_total_pp) + "<br>" + "<br>" + infoTab
        : 'Hover over a polling place');
  };

  info.addTo(map);
  
}
 
```


The allocation from SA1s to polling places is given by the elements of $\boldsymbol{A}$, in this case a `r nrow(t_wentworth_mat)` (polling places) by `r ncol(t_wentworth_mat)` (SA1s) matrix. Of the `r format(prod(dim(t_wentworth_mat)),big.mark=",")` entries in $\boldsymbol{A}$ only `r format(sum(z),big.mark=",")` or `r round(mean(z)*100,1)`% are non-zero, since while many SA1s contribute to any given polling place, most usually do not.^[We find discrepancies between polling place turnout in the vote tallies in AEC results and polling place turnout levels derived by summing the rows of $\boldsymbol{A}$.  For instance, in the [AEC's election results](https://results.aec.gov.au/27966/Website/HouseDivisionPage-27966-152.htm "2022 Federal Election results for Wentworth"), total House of Representatives turnout in Wentworth is `r format(sum(y_wentworth$votes_total_pp),big.mark=",")` while summing over the relevant entries in the AEC's SA1 file produces a figure of `r format(sa1 %>% filter(div_nm=="Wentworth") %>% summarise(n=sum(votes*ratio)) %>% pull(n), big.mark=",")`.   These discrepancies are typically on the order of a handful of votes at the polling place level and for 12 out of 57 polling places the two turnout counts match.   We reconcile these discrepancies by (a) for each polling place, normalise the vote tallies for each party plus informal ballots to sum to the polling place turnout derived from the SA1 file, keeping the parties' vote shares constant; (b) rounding the resulting tallies to the nearest integer; (c) any final adjustment to make the two turnout counts match is made by a (one vote) increment or decrement to the count of informal ballots.]

The _sparsity_ of the $\boldsymbol{A}$ matrix for Wentworth is presented graphically below, with the filled cells in the grid corresponding to non-zero elements of $\boldsymbol{A}$.  Absentee voting, postal ballot and forms of early voting (e.g., pre-poll voting centres or PPVC) draw on almost every SA1 in Wentworth, with the sparsity arising from most Election Day, in-person turnout concentrating at polling places spatially proximate to the voter's SA1.

```{r}
#| label: fig-wentworth-a-matrix
#| fig-width: 11
#| fig-height: 9.5
#| fig-cap: "Contributions of SA1s to polling places in the division of Wentworth in Australia's 2022 elections for the House of Representatives.   Source: Australian Electoral Commission SA1 file."
ggplot(data = ldata,
       aes(x = x, y = y, fill = z)) +
  geom_raster(interpolate = FALSE) +
  scale_fill_manual(values = c("FALSE" = gray(.98), 
                               "TRUE" = "orange"),
                    guide = FALSE) +
  scale_x_discrete("SA1s", expand = c(0, 0)) +
  scale_y_continuous(
    "",
    expand = c(0, 0),
    breaks = 1:nrow(t_wentworth),
    labels = dimnames(z)[[1]]
  ) +
  theme_minimal(base_family = "Avenir") +
  theme(legend.position = "none")
```

The information in @fig-wentworth-pp and summarised in @fig-wentworth-a-matrix constitute the data at hand for now; we introduce Census information at the SA1 level in section XXX.


We now consider two different estimation strategies with the information at hand.

-   a **reverse** strategy, working from the polling place vote shares $\boldsymbol{y}$ backwards through the model to form estimates of $\boldsymbol{x}$.

-   a **forward** model, treating the $\lambda$ as unknown parameters in a statistical model for $\boldsymbol{y}$. This approach opens the possibility of SA1-level covariates $\boldsymbol{z}$ entering the model.

# The reverse strategy

The reverse strategy is widely used in practice. We consider two approaches using this strategy, a **deterministic** estimator and its simulation or **permutation-based** analogue.  

## Deterministic estimator {#sec-deterministic}
Each $\lambda_{ij}$ in @eq-x is to set to the vote proportions observed at its corresponding polling place $i$, i.e.,

$$
\hat{\lambda}_{ij} = y_i / n_i
$$ {#eq-deterministic}

where $n_i = \sum_{j=1}^m A_{ij}$ is the number of voters at polling place $i$. One rationalization for this estimator is that absent any other information, the segment of voters at polling place $i$ originating from SA1 $j$ can not be distinguished from any of the other voters at polling place $i$.  From the perspective of the analyst, it is _as if_ the set of voters at polling place $i$ from SA $j$ comprise a _random sample_ from the set of all voters turning out at polling place $i$.   All such segments are hence *exchangeable* and hence we should assign any particular segment the same vote probabilities as any other segment, for which our best guess is simply the observed vote proportions at polling place $i$ (@eq-deterministic).

The estimator in @eq-deterministic is (a) trivially consistent with the observed data --- confirmed by substituting $\hat{\lambda}_{ij}$ from @eq-deterministic into @eq-y; (b) relies on assumptions so seemingly uncontroversial that they need no justification and are rarely even stated; (c) is easily computed using spreadsheets.

An elaboration of this estimator comes from noting subsets of the voters turning out at polling place $i$ will almost surely have different vote shares than those of the entire set.  That is, for any polling place $i$, its SA1-specific segments $\lambda_{ij}$ will almost surely vary around the polling place shares $y_i/n_i$, a function of the political heterogeneity of the SA1s and the processes leading voters to turn out at particular polling places.   These factors will induce more or less variation in $\lambda_{ij}$.  

So, while @eq-deterministic provides a valid estimate of SA1-level votes --- in the sense of being consistent with the observed data --- it is almost certainly underestimating variation in the $\lambda_{ij}$ _within_ polling places and hence the SA1 vote shares themselves. While recourse to the "principal of insufficient reason" CHECK THIS leads to the deterministic estimator, _any_ set of $\lambda_{ij}$ that satisfy the equality in @eq-y is as valid as any other.

In turn, this observation speaks to the "ill-posed" nature of this inferential problem: in general, there is no unique solution when trying to invert the aggregation of $m$ SA1-level vote shares to $n$ polling place sets of observations, when $m > n$.   

## Permutation-based estimator

Simulation-based methods let us operationalise the variation of $\lambda_{ij}$ around the polling place level vote shares $y_i/n_i$.   For polling place $i$, each SA1 contributes $A_{ij}$ voters, with an unknown set of vote proportions $\lambda_{ij}$.  A permutation-based method for simulating variation in the unobserved $\lambda_{ij}$ is 

1. define a vector $v_i = 1, \ldots, n_i$, indexing voters turning out at polling place $i$; without loss of generality, partition this vector into bins of size $y_i = (y_{i1}, y_{i2}, \ldots, y_{iP})'$ each $y_{ip}$ corresponding to the number of votes for party/candidate $p$ recorded at polling place $i$.  

2. for arbitrarily many iterations $k = 1, \ldots, K$, randomly assign the elements of $v_i$ to $m$ partitions each of size $A_{ij}$, where $j \in 1, \ldots, m$ indexes the SA1s contributing votes to polling place $i$.  This procedures yields a random **permutation** of votes counted at polling place $i$ into originating SA1s.  By construction, each such random permutation is consistent with (a) the polling place vote tallies $y_i$ and (b) the known sizes of the segments of voters by their originating SA1 ($A_{ij}$). 

3. Compute $\zeta^{(k)}_{ij} = (\zeta_{ij1}^{(k)}, \zeta_{ij2}^{(k)}, \ldots, \zeta_{ijP}^{(k)})'$ counts of the $v_i$ voting for party/candidate $p = 1, \ldots, P$ among those $v_i$ assigned to SA1 $j \in 1, \ldots, m$ under permutation $k$.      

4. Recalling @eq-x, form the vectors of SA1-level vote counts $\hat{x}^{(k)}_j = \sum_{i=1}^n \zeta^{(k)}_{ij}$.

5. Average over $K$ iterations to form estimators $\hat{\zeta}_{ij} = \frac{1}{K} \sum_{k=1}^K \zeta^{(k)}_{ij}$; we form 90% credible intervals by computing the 5% and 95% percentiles of each element of the $K$ $\hat{\zeta}_{ij}$.   These estimated vote counts can be also be reported as proportions via @eq-pi.   


## Reverse estimation: application to Wentworth

```{r}
#| label: fig-reverse
#| fig-height: 11
#| fig-cap: "Estimates of vote in Wentworth SA1s, 2022 Federal election, based on 50,000 permutations of votes to SA1s.  Points correspond to estimates vote shares and horizontal lines cover 90% credible intervals. Estimates for SA1s with fewer than 10 voters are highly imprecise and are excluded from the graphs.  Each panel corresponds to results with respect to the indicated party; the data are ordered within each panel; the vertical orange line on each panel indicate the division-wide vote share for the indicated party."
library(ggplot2)
library(tidytext)

load(here("data/2022/wentworth/random_partitions_yyy.RData"))
ggplot(data = yyy %>% filter(n_total > 10),
       aes(
         x = pbar,
         xmin = q05,
         xmax = q95,
         y = reorder_within(SA1_CODE21, by = pbar, within = party)
         )
       ) +
  geom_errorbarh(height = 0, color = gray(.90)) +
  geom_point(color = "blue", size = .15) +
  geom_vline(
    data = y_normed %>% count(party, wt = y_new) %>% mutate(p = n / sum(n)),
    aes(xintercept = p),
    color = "orange",
    size = .25
  ) +
  scale_x_continuous(
    "Vote",
    expand = expansion(add = c(.02, 0)),
    minor_breaks = NULL,
    labels = scales::label_percent(),
    breaks = c(0, .25, .50)
  ) +
  scale_y_discrete("", breaks = NULL, expand = c(.01, .01)) +
  facet_wrap( ~ party, scales = "free") +
  theme_minimal(base_family = "Avenir") +
  theme(panel.border = element_rect(
    fill = NA,
    linewidth = .5,
    colour = gray(.50)
  ))
```

MAP HERE, ideally linked to chart

# Hierarchical Bayesian estimator



# Appendix

The problem given in @eq-y is ill-posed.

Stack the elements of $\boldsymbol{y}$ as a column vector of length $nP$ 
$$
y = 
\left[
\begin{aligned}
y_{11} \\
y_{12} \\
\vdots \\
y_{1P} \\
y_{21} \\
\vdots \\
y_{nP}
\end{aligned}
\right]
$$
and similarly stack the vectors $\zeta_{ij}$, $i \in 1, \ldots, n$ and $j \in 1, \ldots, m$.
